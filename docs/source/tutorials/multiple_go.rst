Multiple Go models
==================


.. note::
    At time of writing, the ``-name`` flag of martinize2 necessary for this tutorial
    is not available in the version of vermouth installed directly via pip. Make sure
    that Vermouth has been installed using:

    .. code-block::

        $ pip install git+https://github.com/marrink-lab/vermouth-martinize/

If you have a system containing several proteins, each of which has been coarse grained with their
own Go model, then extra care needs to be taken during simulation and visualisation. The exact nature
and behaviour of the Go model is outside the scope of this tool, but interested readers are referred to
the excellent work of `Korshunova et al. <https://pubs.acs.org/doi/10.1021/acs.jctc.4c00677>`_ should
they be interested in further details of pitfalls of multiple Go models in a single system.

Simulation set up
-----------------

Martinizing two proteins
^^^^^^^^^^^^^^^^^^^^^^^^

If multiple proteins are martinized with Go models and intended for the same simulation setup, then care
must be taken in the preparation of input files. When the ``-go`` flag is used in Martinize2, two additional
files are written if the Go model is generated successfully: ``go_atomtypes.itp`` and ``go_nbparams.itp``.

For multiple go models, these should first be renamed to indicate which system they're associated with
(otherwise, running martinize2 twice in the same directory will overwrite the files made for the first protein):

.. code-block::

    # martinize the first protein
    $ martinize2 -f prot0_clean.pdb -x prot0_cg.pdb -o prot0_topol.top -go prot0_contact_map.out -name prot0
    $ mv go_nbparams.itp prot0_go_nbparams.itp
    $ mv go_atomtypes.itp prot0_go_atomtypes.itp

    # martinize the second protein
    $ martinize2 -f prot1_clean.pdb -x prot1_cg.pdb -o prot1_topol.top -go prot1_contact_map.out -name prot1
    $ mv go_atomtypes.itp prot1_go_atomtypes.itp
    $ mv go_nbparams.itp prot1_go_nbparams.itp

Once the files are all generated, the ones relevant to the go model should be concatenated together:

.. code-block::

    # concatenate the files together
    $ cat prot0_go_nbparams.itp prot1_go_nbparams.itp > go_nbparams.itp
    $ cat prot0_go_atomtypes.itp prot1_go_atomtypes.itp > go_atomtypes.itp



Generating a structure file
^^^^^^^^^^^^^^^^^^^^^^^^^^^

After the proteins have been coarse-grained individually and the Go files treated accordingly, an initial
simulation cell can be assembled using the program of choice. In the tutorial script, ``gmx insert-molecules``
is used twice over to insert several copies of each into a single simulation cell called ``vis.gro``:


.. code-block::

    # make the box with multiple copies of each molecule using gromacs
    $ gmx insert-molecules -ci prot0_cg.pdb -nmol 5 -box 20 20 20 -o newbox.gro
    $ gmx insert-molecules -ci prot1_cg.pdb -nmol 3 -f newbox.gro  -o vis.gro
    $ rm newbox.gro


Visualisation
-------------


Running MartiniGlass
^^^^^^^^^^^^^^^^^^^^

With the input files treated appropriately, MartiniGlass can in fact be run as with any other system. In the
case of the tutorial files, the following command will generate all the visualisation topologies from the
input files as described above:

.. code-block::

    $ martiniglass -p topol.top -go -gf go_nbparams.itp -vf -f vis.gro

As usual, this can then be opened in vmd:

.. code-block::

    $ vmd vis.gro -e vis.vmd

In the case of the files found in the output folder of the tutorial, the VMD scene looks as the following:

.. image::
    https://github.com/user-attachments/assets/ffcaa37b-7883-452d-a762-e21620e57603

Where the five copies of `prot0` have been coloured in yellow, and the three copies of `prot1` in distinct
colours. In this case, the visualisation of the Go network has been particularly useful for `prot1`, because
the large likely disordered loops generated by AlphaFold have been attached with Go bonds, which will
almost certainly result in unphysical behaviour.

